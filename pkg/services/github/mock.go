// Code generated by MockGen. DO NOT EDIT.
// Source: service.go

// Package github is a generated GoMock package.
package github

import (
	context "context"
	reflect "reflect"

	githubapi "github.com/estafette/estafette-ci-api/pkg/clients/githubapi"
	contracts "github.com/estafette/estafette-ci-contracts"
	manifest "github.com/estafette/estafette-ci-manifest"
	gomock "github.com/golang/mock/gomock"
)

// MockService is a mock of Service interface.
type MockService struct {
	ctrl     *gomock.Controller
	recorder *MockServiceMockRecorder
}

// MockServiceMockRecorder is the mock recorder for MockService.
type MockServiceMockRecorder struct {
	mock *MockService
}

// NewMockService creates a new mock instance.
func NewMockService(ctrl *gomock.Controller) *MockService {
	mock := &MockService{ctrl: ctrl}
	mock.recorder = &MockServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockService) EXPECT() *MockServiceMockRecorder {
	return m.recorder
}

// Archive mocks base method.
func (m *MockService) Archive(ctx context.Context, repoSource, repoOwner, repoName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Archive", ctx, repoSource, repoOwner, repoName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Archive indicates an expected call of Archive.
func (mr *MockServiceMockRecorder) Archive(ctx, repoSource, repoOwner, repoName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Archive", reflect.TypeOf((*MockService)(nil).Archive), ctx, repoSource, repoOwner, repoName)
}

// CreateJobForGithubPush mocks base method.
func (m *MockService) CreateJobForGithubPush(ctx context.Context, event githubapi.PushEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJobForGithubPush", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateJobForGithubPush indicates an expected call of CreateJobForGithubPush.
func (mr *MockServiceMockRecorder) CreateJobForGithubPush(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJobForGithubPush", reflect.TypeOf((*MockService)(nil).CreateJobForGithubPush), ctx, event)
}

// HasValidSignature mocks base method.
func (m *MockService) HasValidSignature(ctx context.Context, body []byte, appIDHeader, signatureHeader string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasValidSignature", ctx, body, appIDHeader, signatureHeader)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasValidSignature indicates an expected call of HasValidSignature.
func (mr *MockServiceMockRecorder) HasValidSignature(ctx, body, appIDHeader, signatureHeader interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasValidSignature", reflect.TypeOf((*MockService)(nil).HasValidSignature), ctx, body, appIDHeader, signatureHeader)
}

// IsAllowedInstallation mocks base method.
func (m *MockService) IsAllowedInstallation(ctx context.Context, installationID int) (bool, []*contracts.Organization) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAllowedInstallation", ctx, installationID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]*contracts.Organization)
	return ret0, ret1
}

// IsAllowedInstallation indicates an expected call of IsAllowedInstallation.
func (mr *MockServiceMockRecorder) IsAllowedInstallation(ctx, installationID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAllowedInstallation", reflect.TypeOf((*MockService)(nil).IsAllowedInstallation), ctx, installationID)
}

// PublishGithubEvent mocks base method.
func (m *MockService) PublishGithubEvent(ctx context.Context, event manifest.EstafetteGithubEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishGithubEvent", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishGithubEvent indicates an expected call of PublishGithubEvent.
func (mr *MockServiceMockRecorder) PublishGithubEvent(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishGithubEvent", reflect.TypeOf((*MockService)(nil).PublishGithubEvent), ctx, event)
}

// Rename mocks base method.
func (m *MockService) Rename(ctx context.Context, fromRepoSource, fromRepoOwner, fromRepoName, toRepoSource, toRepoOwner, toRepoName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rename", ctx, fromRepoSource, fromRepoOwner, fromRepoName, toRepoSource, toRepoOwner, toRepoName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rename indicates an expected call of Rename.
func (mr *MockServiceMockRecorder) Rename(ctx, fromRepoSource, fromRepoOwner, fromRepoName, toRepoSource, toRepoOwner, toRepoName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rename", reflect.TypeOf((*MockService)(nil).Rename), ctx, fromRepoSource, fromRepoOwner, fromRepoName, toRepoSource, toRepoOwner, toRepoName)
}

// Unarchive mocks base method.
func (m *MockService) Unarchive(ctx context.Context, repoSource, repoOwner, repoName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unarchive", ctx, repoSource, repoOwner, repoName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unarchive indicates an expected call of Unarchive.
func (mr *MockServiceMockRecorder) Unarchive(ctx, repoSource, repoOwner, repoName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unarchive", reflect.TypeOf((*MockService)(nil).Unarchive), ctx, repoSource, repoOwner, repoName)
}
